# Структура исходного кода

## Избегайте синглтонов с состоянием

При написании кода только для клиентской стороны можно быстро привыкнуть, что каждый раз код выполняется в новом контексте. Но сервер Node.js — длительный процесс. Поэтому после того как код впервые импортируется процессом и будет выполнен один раз, он затем останется в памяти. Это значит, если создать объект синглтон, то он станет использоваться для всех входящих запросов, что чревато загрязнением состояния при перекрёстных запросах.

Поэтому требуется **для каждого запроса создавать новый корневой экземпляр Vue.** Чтобы сделать это, нужно написать функцию-фабрику, которая сможет многократно выполняться и создавать свежие экземпляры приложения для каждого запроса:

```js{4-5,12-13}
// app.js
const { createSSRApp } = require('vue')

module exports = function createApp() {
  return createSSRApp({
    data() {
      return {
        user: 'Василий Пупкин'
      }
    },
    template: `<div>Текущий пользователь: {{ user }}</div>`
  })
}
```

Код серверной части теперь становится таким:

```js{4,7}
// server.js
const { renderToString } = require('@vue/server-renderer')
const server = require('express')()
const createApp = require('src/app.js')

server.get('*', async (req, res) => {
  const app = createApp()

  const appContent = await renderToString(app)
  const html = `
  <html>
    <body>
      <h1>Мой первый заголовок</h1>
      <div id="app">${appContent}</div>
    </body>
  </html>
  `

  res.end(html)
})

server.listen(8080)
```

Это правило применяется также и к экземплярам роутера (router) или хранилища (store). Вместо того, чтобы непосредственно экспортировать их из модуля и импортировать в приложении, теперь нужно создавать новый экземпляр в `createApp` и внедрять его из корневого экземпляра Vue.

## Добавление шага сборки

До сих пор, ещё не обсуждали каким образом доставлять клиенту такое приложение Vue. Чтобы сделать это, потребуется собрать приложение с использованием webpack.

- Требуется обработать серверный код с помощью webpack. Например, файлы `.vue` нужно обработать с помощью `vue-loader`, а многие специфические для webpack функции, такие как импорт файлов через `file-loader` или импорт CSS через `css-loader`, не будут работать напрямую в Node.js.

- Аналогично, нужна отдельная сборка для клиентской стороны, несмотря на то, что последняя версия Node.js полностью поддерживает возможности ES2015, для старых браузеров необходимо транспилировать код.

Основная идея в том, что webpack будет использоваться для сборки приложения как для клиента, так и для сервера. Серверная сборка будет выполняться на сервере для отрисовки статического HTML, а клиентская сборка будет отправляться в браузер для гидратации получаемой статической разметки.

![архитектура](https://cloud.githubusercontent.com/assets/499550/17607895/786a415a-5fee-11e6-9c11-45a2cfdf085c.png)

Подробнее обсудим в следующих разделах — а сейчас представим, что уже разобрались с настройкой сборки и можем писать код приложения Vue с использованием webpack.

## Структура кода с webpack

Используя webpack для сборки приложения как для сервера, так и для клиента, большая часть исходного кода может быть написана универсально, используя все возможности webpack. В то же время есть ряд вещей, о которых следует помнить при [написании универсального кода](universal.md).

Простой проект может выглядеть так:

```bash
src
├── components
│   ├── MyUser.vue
│   └── MyTable.vue
├── App.vue
├── app.js # универсальная точка входа
├── entry-client.js # запускается только в браузере
└── entry-server.js # запускается только на сервере
```

### `app.js`

`app.js` — универсальная точка входа приложения. В клиентской части приложения, прямо в этом файле создавался бы корневой экземпляр приложения Vue и монтировался в DOM. Но при использовании SSR эта ответственность переносится в файл клиентской точки входа (`entry-client.js`). А файл `app.js` создаёт экземпляр приложения и экспортирует его:

```js
import { createSSRApp } from 'vue'
import App from './App.vue'

// экспортируем функцию фабрику для создания корневого компонента
export default function(args) {
  const app = createSSRApp(App)

  return {
    app
  }
}
```

### `entry-client.js`

Клиентская точка входа создаёт приложение, используя фабрику корневых компонентов, и монтирует его в DOM:

```js
import createApp from './app'

// логика инициализации, специфичная для клиента...

const { app } = createApp({
  // здесь можно передать в фабрику приложений дополнительные аргументы
})

// это предполагает, что в шаблоне App.vue будет корневой элемент с `id="app"`
app.mount('#app')
```

### `entry-server.js`

Серверная точка входа использует экспорт по умолчанию, который представляет собой функцию, вызываемую многократно для каждой отрисовки. На данный момент, она не делает ничего, кроме возврата экземпляра приложения, но позднее здесь добавится серверное сопоставление маршрутов и логика предварительной загрузки данных.

```js
import createApp from './app'

export default function() {
  const { app } = createApp({
    /*...*/
  })

  return {
    app
  }
}
```
